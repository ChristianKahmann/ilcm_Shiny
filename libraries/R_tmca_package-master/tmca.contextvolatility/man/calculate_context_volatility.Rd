% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context_volatility.R
\name{calculate_context_volatility}
\alias{calculate_context_volatility}
\title{Context Volatility}
\usage{
calculate_context_volatility(binDTM = dtm,dates = dates,memory = 6,intervall = "month",cooc_measure = "DICE", significanceThreshold = 0,minCoocFreq = 1,measure = "rank_no_zero",terms)
}
\arguments{
\item{binDTM}{a DocumentTermMatrix in the form of a Matrix::dgCMatrix}

\item{dates}{a vector of strings, each string represents a date}

\item{memory}{an integer used for Defaults to 3.}

\item{intervall}{a string specifying the time intervall('day','week',month','year'). Default to month.}

\item{cooc_measure}{a string specifying the coocurrence measure('DICE', 'LOGLIK', 'MI', 'COUNT') Default to DICE.}

\item{terms}{a vector of strings for which the context volatility should be computed. Defaults to NULL.}

\item{significanceThreshold}{a number which determinds a threshold. Significances below this threshold will be set to zero.}

\item{minCoocFreq}{a number specifying the minimal times a cooocurrence has to appear, for it not beeing set to 0. Defaults to 1.}

\item{maxCoocFreq}{a number specifying the maximal times a cooccurrence can appear, for it not beeing set to 0}

\item{wf}{a string specifying the weightfactor. Defaults to linear.}

\item{logfile}{a string specifying the name of the logfile if NULL then it just prints out the message to the console. Defaults to NULL.}

\item{meassure}{a string specifying if the context volatility significance, context volatility significance window or the context volatility rank should be computed. Default to rank_no_zero.}

\item{Coocs_TimeSlices}{a list with a sublist for each unique date containing a coocurrence matrix for the whole vocabulary}

\item{global}{a large dgCMatrix containing a coocurrence matrix for the whole vocabulary}

\item{method}{a string specifying which method should be used. (method options for computing context volatility significance are 'standard' or 'cosine')(method options for computing context volatility significance windows are 'sig_vc' or 'sig_sd')(method options for computing context volatility rank are 'no_zero', 'max_rank', 'recommender', 'minmax')}

\item{weightfactor}{a number specifying the computed weightfactor}

\item{time}{a number specifying a counter which is used to determine which TimeSlice should be used for the computation}

\item{context}{a list containing the coocurrent words of each term}

\item{term}{a string out of vector of the terms}

\item{coocsYear}{a copy of Coocs_TimeSlices}

\item{vocabIns}{a vector of strings containing the vocabulary}

\item{data}{a list containing a sublist of Coocs_TimeSlices}

\item{Term_Term_Matrix}{a list containing multiple sublists of Coocs_TimeSlices. The amount of sublists is set by the parameter memory.}

\item{indices}{a list containing a sublist for each term. Those sublist contain the indices of the coocurrent words to the term.}

\item{index_max}{a number specifying the maximum index}

\item{word}{a string specifying a word out of the vocabulary}

\item{data_ranked}{a list containing multiple sublists. Each sublist contains a matrix which holds the ranks of the coocurrent word to the terms. The amount of sublists is set by the parameter memory.}

\item{wordvector}{a row of a Term_Term_Matrix of a single term.}

\item{array}{a multidimensional array}

\item{message}{a string specifying what should be printed out or printed into a logfile}

\item{x}{a vector containing numbers}

\item{vector}{a vector containing numbers}
}
\description{
Calculate context volatility based on a dtm and a corresponding date vector.
 Different approaches for calculating context volatility are integrated
}
\details{
Implementation of the measure context volatility
}
\section{context_volatility-methods}{

\describe{
   \item{\code{calculate_context_volatility(binDTM, dates, memory = 3, intervall = 'month', cooc_measure = 'DICE', significanceThreshold = 0, minCoocFreq = 1, maxCoocFreq = 1000000, measure, wf = 'linear', terms = NULL, logfile = NULL)}}{Computes the context volatility significance, context volatility significance window or the context volatility rank based on the used measure('sig_simple', 'sig_cosine', 'sig_vc_window', 'rank_minmax', 'rank_no_zero', 'rank_max_rank', 'rank_recommender')
   
   sig_simple: Calls the method calculate_context_volatility_sig with the parameter method='standard'.
   
   sig_cosine: Calls the method calculate_context_volatility_sig with the parameter method='cosine'.
   
   sig_vc_window: Calls the method calculate_context_volatility_sig_window with the parameter method='sig_vc'.
   
   sig_sd_window: Calls the method calculate_context_volatility_sig_window with the parameter method='sig_sd'.
   
   rank_minmax: Calls the method calculate_context_volatility_rank with the parameter method='minmax'.
   
   rank_no_zero: Calls the method calculate_context_volatility_rank with the parameter method='no_zero'.
   
   rank_max_rank: Calls the method calculate_context_volatility_rank with the parameter method='max_rank'.
   
   rank_recommender: Calls the method calculate_context_volatility_rank with the parameter method='recommender'.
   
   }
   
}
}

\section{context_volatility_sig-methods}{

\describe{
   \item{\code{calculate_context_volatility_sig(Coocs_TimeSlices,global,memory,terms=NULL,wf="linear",method)}}{Computes the distance of the significance values of every term in a context to the previous contexts of every term for all time slices with a weightfactor which is created beforehand. The weightfactors are either 'linear' or 'exp'}
   \item{\code{calc_distance_sig(Coocs_TimeSlices,time,memory,context,method,weightfactor,terms)}}{Computes the distance of the significance values of the time slices depending on the used method(standard, cosine)
   
   standard: Subtracts from the coocurrence matrix of the time slice time all coocurrence matrices of all previous time slices. Afterwards it computes the absmean of all significance values for each term.
   
   cosine: Computes the cosine similarity of the local context of a term and the previous contexts of the term. Afterwards it computes and saves the cosine distance in a list.
}  
   \item{\code{rbind_contexts(Coocs_TimeSlices,term,time,memory)}}{Rbinds to a coocurrence matrix of an initial time slice which consist of all coocurrent words of the terms all other coocurrence matrices of all following time slices up to a given 'time'.}
}
}

\section{context_volatility_sig_window-methods}{

\describe{
   \item{\code{calculate_context_volatility_sig_window(Coocs_TimeSlices,memory,terms,method)}}{Computes the Coefficient of Variation or the Standard deviation of all significance values of all coocurrent words for each term in each time slice based on used method 'sig_vc' or sig_sd'.}
   \item{\code{VarCoef(x)}}{Computes the Coefficient of Variation}
}
}

\section{context_volatility_ranks-methods}{

\describe{
   \item{\code{calculate_context_volatility_rank(Coocs_TimeSlices,memory,method,terms,global)}}{Computes the mean distance or mean IQR of the ranks of the coocurrent words of each term in each time slice. Computes the mean distance when the method is 'minmax' else it computes the mean IQR.}
   \item{\code{create_matrix_words(coocsYears,vocabIns)}}{Creates a matrix in which each column represents a single date and the row the amount of a coocurrent words from the vocabulary .}
   \item{\code{create_wordList(coocsYears,vocabIns,global,terms)}}{Creates a wordlist of the coocurrent words of each term which appear in the vocabulary  of the timeslice.}
   \item{\code{getIndices(data,terms)}}{Returns a vector with the indices of the coocurrent words of the terms in the data.}
   \item{\code{apply_Rank(Term_Term_Matrix,method,indices,terms,index_max)}}{Applying rank depending on the used method('no_zero', 'max_rank', 'recommender', 'minmax')
   
   no_zero: Not applying ranks to not observable cooccurrences.
   
   max_rank: Set non observable coocurrences to max rank.
   
   recommender: Adjusts the matrix with the function adjust_Matrix() before applying ranks.
   
   minmax: Creates a list with two sublist which each contain a rank matrix the first one is ranked with ties.method='min' and the second one with ties.method='max'
   
   }
   \item{\code{adjust_wordvector(Term_Term_Matrix,word,indices,terms)}}{It adjusts a wordvector of a Term_Term_Matrix through setting the terms significance to 0 and replace the other 0-significance with an approximate significance.}
   \item{\code{adjust_Matrix(Term_Term_Matrix,indices,terms)}}{It adjusts the Term_Term_Matrix through setting the terms significance to 0 and replace the other 0-significance with an approximate significance. Calls the adjusts_wordvector function. }
   \item{\code{calcDistance(data_ranked,terms,indices)}}{Computes the distances of the ranks of coocurrent words in different time slices for each term. Weights higher ranks more than lower ranks.}
   \item{\code{rangDecr(wordvector)}}{Apply rank for 1 wordvector beginning by 1. for the biggest value, keeping na's}
   \item{\code{getIQR(array,terms)}}{Computes the inter quartile range(IQR) of all ranks that the cooccurents of a term take for all time slices in a given history.}
   \item{\code{getVarCoef(array,terms)}}{Computes the Coefficient of Variation of all ranks that the cooccurents of a term take for all time slices in a given history.}
   \item{\code{getSD(array,terms)}}{Computes the standard deviation of all ranks that the cooccurents of a term take for all time slices in a given history.}
   \item{\code{IQRNA(x)}}{Computes IQR and removes NA-Values.}
}
}

\section{help functions}{

\describe{
   \item{\code{min_no_na(vector)}}{Returns the smallest value of the vector.}
   \item{\code{max_no_na(vector)}}{Returns the biggest value of the vector.}
   \item{\code{mean_no_na(vector)}}{Returns the mean of the numbers of the vector.}
   \item{\code{sum_no_na(vector)}}{Returns the sum of the numbers of the vector.}
   \item{\code{abs_sum(vector)}}{Returns the absolute sum of the numbers of the vector.}
   \item{\code{abs_mean(vector)}}{Returns the absolute mean of the numbers of the vector.}
   \item{\code{abs_mean_TI(vector)}}{Removes all zeros of the vector and returns the absolute mean of the numbers of the vector.}
   \item{\code{printlog(message, logfile = NULL)}}{If logfile NULL it prints to console and if logfile is given it prints to the log file.}
}
}

\examples{

library(tm)

text = c("These are 4 example sentences.",
   "Nothing special is happening in this example sentences",
   "Every example sentence has a different date.",
   "The date is an example for meta information that will be kept.",
   "I need 2 more example sentences.",
   "So my example works.")
   
text = tm::removePunctuation(text)
   
dates =(c("2018-01-09","2018-01-06","2018-04-07","2018-04-08", "2018-02-04", "2018-02-05"))

corpus <- Corpus(VectorSource(text))
dtm <- as(as.matrix(DocumentTermMatrix(corpus)), 'dgCMatrix')
row.names(dtm) <- dates
 

vola = calculate_context_volatility(binDTM = dtm, dates = dates, memory = 1, intervall = 'month', cooc_measure = 'DICE', significanceThreshold = 0, minCoocFreq = 1, maxCoocFreq = 1000000, measure = "sig_simple", terms = c('example', 'sentence', 'date'), logfile = NULL)

}
\author{
Christian Kahmann, Ahmad Dawar Hakimi
}
