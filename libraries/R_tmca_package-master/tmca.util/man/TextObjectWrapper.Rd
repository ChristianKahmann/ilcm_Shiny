% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TextObjectWrapper.R
\docType{data}
\name{TextObjectWrapper}
\alias{TextObjectWrapper}
\title{Implementation of a Wrapper around Quanteda and Spacy backend. You can manage different options for preprocessing and use the advantages of both backends.}
\format{R6Class}
\usage{
TextObjectWrapper$new() # for a new instance, then use any of the methods described below.
}
\description{
Class to manage a Textobject and in and output various data formats. Also for text processing.
 Wrapper around different abtractions of textprocessing and analysis libraries like quanteda, or spacyr
}
\section{Slots}{

\describe{
\item{\code{backend_object}}{(private) Currently used backend.}

\item{\code{internal_representation}}{(private) Data in the internal format which is the current return of the backend(maybe spacyr_parsed or one of the quanteda formats
).}

\item{\code{input_untouched}}{(private) The object always carries a copy of the  original input data. If you use the `reset()` method your progress will be reset to this.}

\item{\code{spacy_was_used}}{(private) Boolean indicating whether spacyr was used. If you try to use the output method to converse into your desired format and spacy was used beforehand, then the meta information of the input needs to be merged back again.}

\item{\code{logfile}}{(private) Slot indicating whether to print, do nothing, or append to a logfile.}
}}

\section{Methods}{

\describe{
  \item{\code{input()}}{Input of the raw text. This can be a data frame or a tibble or a quanteda corpus. If it is a data.frame or a qibble it should contain the douments in a column calls "text". Additional coluns will be kept as meta information.}
  \item{\code{logging(o = NULL)}}{If NULL (default)information will be printed to console. If "silent" then nothing will be printed. If anything other than silent or NULL, a logfile of this name is searched for and appended to. }
  \item{\code{get_options(name)}}{Gives you the available preprocessing options of a backend (spacyr or quanteda)}
  \item{\code{process(control, backend)}}{Executes a control element in combination with the choice of backend. Additionally returns the raw return value of the backend. (Can be directly piped into the 'output'- method).}
  \item{\code{fullprocess(control)}}{Wrapper for the process method. Allows you to define just one control element that contains control elements for both backends.}
   \item{\code{output()}}{Converts the current State of processing to the desired output format. At the moment possible options include:
    - spacyr_parsed
    - dfm
    - sparseMatrix
   }
   \item{\code{get_original_documents()}}{Get a data.frame with the concatenated documents from input. (Before processing)}
   \item{\code{get_meta_data()}}{If you used input_spacyr_object, You can use this to retrieve the meta data after preprocessing.(Only Current version if you called output between preocess and get_meta_data)}
   \item{\code{input_spacyr_object(x, meta_data=NULL)}}{Input a Spacyobject, possibly with meta_data. meta_data should be a data.frame with a column doc_id.}
  
}
}

\examples{
# Example definition of a Text input with metadata and two control inputs
text_df <- dplyr::data_frame( 
   text = c("These are 4 example sentences.",
   "Nothing special is happening in this example sentences",
   "Every example sentence has a different date.",
   "The date is an example for meta information that will be kept.") , 
   date=(c("2018-04-09","2018-04-06","2018-04-07","2018-04-08")))
control1 = list() # Empty control for spacy will at least tokenize
control2= list(
   ngrams = c(1),
   remove_stopwords = T,
   tolower = T,
   remove_numbers  = T,
   char_length = c(5,10))
   
# You should initialize spacy to the version you want to use
   spacyr::spacy_initialize()
# Also you need to load dplyr style piping  
   library(dplyr)   
   
# You can execute these control elements with the process method
   
   tow = TextObjectWrapper$new()
# You can specify if any output will be printed  
   tow$logging(NULL) # Will print to console (default). If "silent" nothing will be printed, any other string will interpreted as location of a logging file
   
   
   tow$input(text_df)
   
# x will contain the raw return value. spacyr_parsed in the first example quanteda::tokens in the second
   x = tow$process(control1, "spacyr") 
   x = tow$process(control2, "quanteda")
   
# If you need other formats you can use the output method like:
dfm1 = tow$output(x, format = "dfm")

# To reset the current processing use
tow$reset()

# Alternatively (if you dont need the interim results) you can define the whole process in one control element like:
fullcontrol = list(
  spacyr = control1,
  quanteda= control2)
dfm2 = tow$fullprocess(fullcontrol) \%>\% tow$output(format = "dfm")

# The output dfms are equivalent ( but not necessarily in the same order inside the dfm ))
all.equal(sort(quanteda::featnames(dfm1)),sort(quanteda::featnames(dfm2)))
all.equal(sum(quanteda::ntoken(dfm1)),sum(quanteda::ntoken(dfm2)))

# And the contain the original docvars
quanteda::docvars(dfm1)
quanteda::docvars(dfm2)

spacyr::spacy_finalize()

   


}
\author{
Janos Borst
}
\keyword{datasets}
